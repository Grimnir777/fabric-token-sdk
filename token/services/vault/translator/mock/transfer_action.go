// Code generated by counterfeiter. DO NOT EDIT.
package mock

import (
	"sync"

	"github.com/hyperledger-labs/fabric-token-sdk/token/services/vault/translator"
)

type TransferAction struct {
	SerializeStub        func() ([]byte, error)
	serializeMutex       sync.RWMutex
	serializeArgsForCall []struct{}
	serializeReturns     struct {
		result1 []byte
		result2 error
	}
	serializeReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	NumOutputsStub        func() int
	numOutputsMutex       sync.RWMutex
	numOutputsArgsForCall []struct{}
	numOutputsReturns     struct {
		result1 int
	}
	numOutputsReturnsOnCall map[int]struct {
		result1 int
	}
	GetSerializedOutputsStub        func() ([][]byte, error)
	getSerializedOutputsMutex       sync.RWMutex
	getSerializedOutputsArgsForCall []struct{}
	getSerializedOutputsReturns     struct {
		result1 [][]byte
		result2 error
	}
	getSerializedOutputsReturnsOnCall map[int]struct {
		result1 [][]byte
		result2 error
	}
	IsRedeemAtStub        func(index int) bool
	isRedeemAtMutex       sync.RWMutex
	isRedeemAtArgsForCall []struct {
		index int
	}
	isRedeemAtReturns struct {
		result1 bool
	}
	isRedeemAtReturnsOnCall map[int]struct {
		result1 bool
	}
	SerializeOutputAtStub        func(index int) ([]byte, error)
	serializeOutputAtMutex       sync.RWMutex
	serializeOutputAtArgsForCall []struct {
		index int
	}
	serializeOutputAtReturns struct {
		result1 []byte
		result2 error
	}
	serializeOutputAtReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	GetInputsStub        func() ([]string, error)
	getInputsMutex       sync.RWMutex
	getInputsArgsForCall []struct{}
	getInputsReturns     struct {
		result1 []string
		result2 error
	}
	getInputsReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	IsGraphHidingStub        func() bool
	isGraphHidingMutex       sync.RWMutex
	isGraphHidingArgsForCall []struct{}
	isGraphHidingReturns     struct {
		result1 bool
	}
	isGraphHidingReturnsOnCall map[int]struct {
		result1 bool
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *TransferAction) Serialize() ([]byte, error) {
	fake.serializeMutex.Lock()
	ret, specificReturn := fake.serializeReturnsOnCall[len(fake.serializeArgsForCall)]
	fake.serializeArgsForCall = append(fake.serializeArgsForCall, struct{}{})
	fake.recordInvocation("Serialize", []interface{}{})
	fake.serializeMutex.Unlock()
	if fake.SerializeStub != nil {
		return fake.SerializeStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.serializeReturns.result1, fake.serializeReturns.result2
}

func (fake *TransferAction) SerializeCallCount() int {
	fake.serializeMutex.RLock()
	defer fake.serializeMutex.RUnlock()
	return len(fake.serializeArgsForCall)
}

func (fake *TransferAction) SerializeReturns(result1 []byte, result2 error) {
	fake.SerializeStub = nil
	fake.serializeReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *TransferAction) SerializeReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.SerializeStub = nil
	if fake.serializeReturnsOnCall == nil {
		fake.serializeReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.serializeReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *TransferAction) NumOutputs() int {
	fake.numOutputsMutex.Lock()
	ret, specificReturn := fake.numOutputsReturnsOnCall[len(fake.numOutputsArgsForCall)]
	fake.numOutputsArgsForCall = append(fake.numOutputsArgsForCall, struct{}{})
	fake.recordInvocation("NumOutputs", []interface{}{})
	fake.numOutputsMutex.Unlock()
	if fake.NumOutputsStub != nil {
		return fake.NumOutputsStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.numOutputsReturns.result1
}

func (fake *TransferAction) NumOutputsCallCount() int {
	fake.numOutputsMutex.RLock()
	defer fake.numOutputsMutex.RUnlock()
	return len(fake.numOutputsArgsForCall)
}

func (fake *TransferAction) NumOutputsReturns(result1 int) {
	fake.NumOutputsStub = nil
	fake.numOutputsReturns = struct {
		result1 int
	}{result1}
}

func (fake *TransferAction) NumOutputsReturnsOnCall(i int, result1 int) {
	fake.NumOutputsStub = nil
	if fake.numOutputsReturnsOnCall == nil {
		fake.numOutputsReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.numOutputsReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *TransferAction) GetSerializedOutputs() ([][]byte, error) {
	fake.getSerializedOutputsMutex.Lock()
	ret, specificReturn := fake.getSerializedOutputsReturnsOnCall[len(fake.getSerializedOutputsArgsForCall)]
	fake.getSerializedOutputsArgsForCall = append(fake.getSerializedOutputsArgsForCall, struct{}{})
	fake.recordInvocation("GetSerializedOutputs", []interface{}{})
	fake.getSerializedOutputsMutex.Unlock()
	if fake.GetSerializedOutputsStub != nil {
		return fake.GetSerializedOutputsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getSerializedOutputsReturns.result1, fake.getSerializedOutputsReturns.result2
}

func (fake *TransferAction) GetSerializedOutputsCallCount() int {
	fake.getSerializedOutputsMutex.RLock()
	defer fake.getSerializedOutputsMutex.RUnlock()
	return len(fake.getSerializedOutputsArgsForCall)
}

func (fake *TransferAction) GetSerializedOutputsReturns(result1 [][]byte, result2 error) {
	fake.GetSerializedOutputsStub = nil
	fake.getSerializedOutputsReturns = struct {
		result1 [][]byte
		result2 error
	}{result1, result2}
}

func (fake *TransferAction) GetSerializedOutputsReturnsOnCall(i int, result1 [][]byte, result2 error) {
	fake.GetSerializedOutputsStub = nil
	if fake.getSerializedOutputsReturnsOnCall == nil {
		fake.getSerializedOutputsReturnsOnCall = make(map[int]struct {
			result1 [][]byte
			result2 error
		})
	}
	fake.getSerializedOutputsReturnsOnCall[i] = struct {
		result1 [][]byte
		result2 error
	}{result1, result2}
}

func (fake *TransferAction) IsRedeemAt(index int) bool {
	fake.isRedeemAtMutex.Lock()
	ret, specificReturn := fake.isRedeemAtReturnsOnCall[len(fake.isRedeemAtArgsForCall)]
	fake.isRedeemAtArgsForCall = append(fake.isRedeemAtArgsForCall, struct {
		index int
	}{index})
	fake.recordInvocation("IsRedeemAt", []interface{}{index})
	fake.isRedeemAtMutex.Unlock()
	if fake.IsRedeemAtStub != nil {
		return fake.IsRedeemAtStub(index)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.isRedeemAtReturns.result1
}

func (fake *TransferAction) IsRedeemAtCallCount() int {
	fake.isRedeemAtMutex.RLock()
	defer fake.isRedeemAtMutex.RUnlock()
	return len(fake.isRedeemAtArgsForCall)
}

func (fake *TransferAction) IsRedeemAtArgsForCall(i int) int {
	fake.isRedeemAtMutex.RLock()
	defer fake.isRedeemAtMutex.RUnlock()
	return fake.isRedeemAtArgsForCall[i].index
}

func (fake *TransferAction) IsRedeemAtReturns(result1 bool) {
	fake.IsRedeemAtStub = nil
	fake.isRedeemAtReturns = struct {
		result1 bool
	}{result1}
}

func (fake *TransferAction) IsRedeemAtReturnsOnCall(i int, result1 bool) {
	fake.IsRedeemAtStub = nil
	if fake.isRedeemAtReturnsOnCall == nil {
		fake.isRedeemAtReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isRedeemAtReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *TransferAction) SerializeOutputAt(index int) ([]byte, error) {
	fake.serializeOutputAtMutex.Lock()
	ret, specificReturn := fake.serializeOutputAtReturnsOnCall[len(fake.serializeOutputAtArgsForCall)]
	fake.serializeOutputAtArgsForCall = append(fake.serializeOutputAtArgsForCall, struct {
		index int
	}{index})
	fake.recordInvocation("SerializeOutputAt", []interface{}{index})
	fake.serializeOutputAtMutex.Unlock()
	if fake.SerializeOutputAtStub != nil {
		return fake.SerializeOutputAtStub(index)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.serializeOutputAtReturns.result1, fake.serializeOutputAtReturns.result2
}

func (fake *TransferAction) SerializeOutputAtCallCount() int {
	fake.serializeOutputAtMutex.RLock()
	defer fake.serializeOutputAtMutex.RUnlock()
	return len(fake.serializeOutputAtArgsForCall)
}

func (fake *TransferAction) SerializeOutputAtArgsForCall(i int) int {
	fake.serializeOutputAtMutex.RLock()
	defer fake.serializeOutputAtMutex.RUnlock()
	return fake.serializeOutputAtArgsForCall[i].index
}

func (fake *TransferAction) SerializeOutputAtReturns(result1 []byte, result2 error) {
	fake.SerializeOutputAtStub = nil
	fake.serializeOutputAtReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *TransferAction) SerializeOutputAtReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.SerializeOutputAtStub = nil
	if fake.serializeOutputAtReturnsOnCall == nil {
		fake.serializeOutputAtReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.serializeOutputAtReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *TransferAction) GetInputs() ([]string, error) {
	fake.getInputsMutex.Lock()
	ret, specificReturn := fake.getInputsReturnsOnCall[len(fake.getInputsArgsForCall)]
	fake.getInputsArgsForCall = append(fake.getInputsArgsForCall, struct{}{})
	fake.recordInvocation("GetInputs", []interface{}{})
	fake.getInputsMutex.Unlock()
	if fake.GetInputsStub != nil {
		return fake.GetInputsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getInputsReturns.result1, fake.getInputsReturns.result2
}

func (fake *TransferAction) GetInputsCallCount() int {
	fake.getInputsMutex.RLock()
	defer fake.getInputsMutex.RUnlock()
	return len(fake.getInputsArgsForCall)
}

func (fake *TransferAction) GetInputsReturns(result1 []string, result2 error) {
	fake.GetInputsStub = nil
	fake.getInputsReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *TransferAction) GetInputsReturnsOnCall(i int, result1 []string, result2 error) {
	fake.GetInputsStub = nil
	if fake.getInputsReturnsOnCall == nil {
		fake.getInputsReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.getInputsReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *TransferAction) IsGraphHiding() bool {
	fake.isGraphHidingMutex.Lock()
	ret, specificReturn := fake.isGraphHidingReturnsOnCall[len(fake.isGraphHidingArgsForCall)]
	fake.isGraphHidingArgsForCall = append(fake.isGraphHidingArgsForCall, struct{}{})
	fake.recordInvocation("IsGraphHiding", []interface{}{})
	fake.isGraphHidingMutex.Unlock()
	if fake.IsGraphHidingStub != nil {
		return fake.IsGraphHidingStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.isGraphHidingReturns.result1
}

func (fake *TransferAction) IsGraphHidingCallCount() int {
	fake.isGraphHidingMutex.RLock()
	defer fake.isGraphHidingMutex.RUnlock()
	return len(fake.isGraphHidingArgsForCall)
}

func (fake *TransferAction) IsGraphHidingReturns(result1 bool) {
	fake.IsGraphHidingStub = nil
	fake.isGraphHidingReturns = struct {
		result1 bool
	}{result1}
}

func (fake *TransferAction) IsGraphHidingReturnsOnCall(i int, result1 bool) {
	fake.IsGraphHidingStub = nil
	if fake.isGraphHidingReturnsOnCall == nil {
		fake.isGraphHidingReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isGraphHidingReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *TransferAction) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.serializeMutex.RLock()
	defer fake.serializeMutex.RUnlock()
	fake.numOutputsMutex.RLock()
	defer fake.numOutputsMutex.RUnlock()
	fake.getSerializedOutputsMutex.RLock()
	defer fake.getSerializedOutputsMutex.RUnlock()
	fake.isRedeemAtMutex.RLock()
	defer fake.isRedeemAtMutex.RUnlock()
	fake.serializeOutputAtMutex.RLock()
	defer fake.serializeOutputAtMutex.RUnlock()
	fake.getInputsMutex.RLock()
	defer fake.getInputsMutex.RUnlock()
	fake.isGraphHidingMutex.RLock()
	defer fake.isGraphHidingMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *TransferAction) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ translator.TransferAction = new(TransferAction)
